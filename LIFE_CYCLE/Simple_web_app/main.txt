

		Исполнение

			(	Приожение не работает как надо, картинки не загржуаются,
				я попроовал обрптиться через браузер к серверу, который
				мы указываем в запросе, он не отвечает, думаю, что из-за
				этого и не работатет
			)

			{ 
				Данное приложение разработано в соответствии с архитектурой
				микросервиса, когда системы компануются из небольших и неза-
				висимых сервисов. Если бы система была монолитной, то пришлось
				бы разрабатывать компоненты dnmoster, Redis и identidock на
				базе одного языка программирования. 

				В нашем приложении identidock написан на python, 
				который обменивается данными с JavaScript сервисом dnmonster 
				и с хранилищем Redis, написанным на C.

				При этом компоненты разделены по 3м контейнерам

				Плюсы микросервисов:
					+ Масштабирование на большое кол-во сетевых компьютеров
					+ Отдельные сервисы можно быстро заменять
					+ Можно использовтаь различные языки программирования
					
				Минусы микросервисов:
					- Обмен данных по сети, а не через вызов функций библиотек
					- Использование дополнительных средств как Compose
					+-Постоянный анализ необходимости тех или иных сервисов
			}

				Нужно написать основную страницу в indentidock.py (mainpage),
				затем нужно получить картинку монстра через запрос к ресурсу,
				для запросов и получения ответа нужно подключить соответствующие
				блиотеки request и Response(из Flask) и получить это изображение
				в функции (get_identicon). В Dockerfile нужно указать, что нужно 
				загруэать библиотеку request

				Затем следует создать коннтейнер (в данном случае без Compose)
				и загрузить dnmonster из репозитория, так как мы работаем с ним 
				впервые.

						docker build -t identidock .
						docker run -d --name dnmonster amout/dnmonster:1.0

				Далее следует запустить приложение. Ключевой момент состоит в том,
				что мы соединям 2 контейнера через аргумент --link.

						docker run -d -p 5000:5000 -e "ENV=DEV" --link dnmonster:dnmonster identidock

				Снова к Compose:
					Чтобы избавиться от запоминания предыдущих команд нужно использовтаь 
					Compose и записать в docker-compose.yml следующие данные:

							identidock:
							  link:
							    - dnmonster

							dnmonster:
							  image: amouat/dnmonster:1.0

					Перед запуском конетйнера следует удалить предыдущие контейнеры:

							sudo docker rm $(sudo docker stop ps -q)

				Добавим хэширование имени в identidock, чтобы можно было пердавать 
				и пробельные символы

						import hashlib
						salt = "UNIQUE_SALT"

						@app.route('/', methods=['GET', 'POST'])
						def mainpage():
								...
								if request.method=='POST':
										...
										name_hash = haslib.sha256( salted_name.encode() ).hexdigest()

								body = '''...'''.format( name, name_hash) 


				Каждый раз обращаться к серевру dnmonsters ресурсозатратно, поэтому, чтобы
				нужно кэировать первый полученный от него результат пикторграммы.
				Для такой задачи подойдет храилище типа ключ-значение.
				Разместим Redis в новом контейнере, чтобы соответствовать идеологии
				один контейнер - одно приложение.
				Чтобы использовть кэш нужно внести изменения в код identidock.py:

						import redis

						app = Flask(__name__)
						cache = redis.StrictRedis( host='redis', port=6369, db=0)
							...
						@app.route('monster/<name>')
						def get_identicon( name )

								image = cache.get( name )
								if image is None:
										print( "Cache miss (промах кэша)", flush=True)
										...
										cache.set( name, image )

				Так как мы использем новый модуль Redis, то нужно внести изменения в файлы
				Dockerfile и docker-compose.yml:

						Dockerfile:

							RUN pip install redis==2.10.3

						docker-compose.yml:
							identidock:
							  links:
							    - dnmonster
							    - redis						

							redis:
							  image: redis:3.0

				Далее следует создать и запустить приложение:

						docker-compose build
						docker-compose up